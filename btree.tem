#include <algorithm>

template <typename T>
btree<T>::btree(size_t maxNodeElems) : maxNodeElems(maxNodeElems), prev_(Const::null) { 
    nodes_type nodes();
}

template <typename T>
btree<T>::btree(const btree<T>& original) {
    
}

template <typename T>
std::ostream& operator<<(std::ostream& os, const btree<T>& tree) {
    for (typename btree<T>::nodes_type::const_iterator it = tree.nodes.begin(); 
         it != tree.nodes.end(); ++it) {
        os << *it;
    }
    return os;
}

template <typename T>
std::pair<typename btree<T>::iterator, bool> btree<T>::insert(const T& elem) {
    Node n(elem);
    if (nodeElems() < maxNodeElems) { // no need for branching
        nodes.insert(n);
    } else { // put the elem in a sub-btree

        // The new sub-btree
        btree<T>* subtree = new btree<T>(maxNodeElems);
        subtree->insert(elem);
        cout << "new subtree " << *subtree << endl;

        // iterators to nodes
        nodes_iterator_type top_right = nodes.lower_bound(n);
        //nodes_iterator_type top_left = top_right - 1;

        // modify the nodes
        top_right->left_ = subtree;
        --top_right->right_ = subtree;
        
        
        
        //lower->left_ = Const::null;
    }
}

template <typename T>
btree<T>::~btree() {
    cout << "~btree" << endl;
    // Nodes will destroy their right branch therefore
    // remember to destroy the first left most branch
    if (nodeElems() > 0) {
        btree* leftTree = nodes.begin()->left_;
        if (leftTree != Const::null) leftTree->~btree();
    }
}

template <typename T>
size_t btree<T>::nodeElems() {
    return nodes.size();
}                                                                           
