#include <algorithm>

template <typename T>
btree<T>::btree(size_t maxNodeElems) : maxNodeElems(maxNodeElems), 
                                       top_left_(Const::null), 
                                       top_right_(Const::null) { 
    nodes_type nodes();
}

template <typename T>
btree<T>::btree(const btree<T>& original) {
    
}

template <typename T>
std::ostream& operator<<(std::ostream& os, const btree<T>& tree) {
    for (typename btree<T>::nodes_type::const_iterator it = tree.nodes.begin(); 
         it != tree.nodes.end(); ++it) {
        os << *it;
    }
    return os;
}

template <typename T>
std::pair<typename btree<T>::iterator, bool> btree<T>::insert(const T& elem) {
    Node n(elem);
    if (nodeElems() < maxNodeElems) { // no need for branching
        nodes.insert(n);
    } else { // put the elem in a sub-btree

        // The new sub-btree
        btree<T>* subtree = new btree<T>(maxNodeElems);
        subtree->insert(elem);
        cout << "new subtree " << *subtree << endl;

        // find insert pos to insert sub-btree
        nodes_iterator_type pos = nodes.lower_bound(n);

        // modify the pointers
        if (pos != nodes.end())     pos->left_ = subtree; // top right node
        
        if (pos != nodes.begin()) --pos->right_ = subtree; // top left node
        
        
        
        //lower->left_ = Const::null;
    }
}

template <typename T>
btree<T>::~btree() {
    cout << "~btree" << endl;
    // Nodes will destroy their right branch therefore
    // remember to destroy the first left most branch
    if (nodeElems() > 0) {
        btree* leftTree = nodes.begin()->left_;
        if (leftTree != Const::null) leftTree->~btree();
    }
}

template <typename T>
size_t btree<T>::nodeElems() {
    return nodes.size();
}                                                                           
